## JVM调优策略

如果使用缺省设置时，堆操作未针对您的应用程序提供最佳结果，那么您可以采取某些措施。

对于大多数应用程序，缺省设置能够正常工作。 堆扩展直至其达到稳定状态，然后保持该状态，这需要提供 70% 的堆占用率（任何给定时间上堆中的活动数据量）。在此级别上，垃圾回收和暂停时间的频率应该可以接受。

对于某些应用程序，缺省设置可能不会提供最佳结果。此处列出了一些可能会发生的问题，以及建议您采取的一些措施。使用 verbose:gc 可帮助您监视堆。

在堆到达稳定状态之前，垃圾回收的频率过高。
使用 verbose:gc 来确定处于稳定状态时的堆大小并将 -Xms 设置为该值。
堆已完全扩展，并且占有率级别超过 70%。
增大 -Xmx 值以便堆占用率不超过 70%。如果可能，最大堆大小应该能够包含在物理内存中以避免出现页面调度。为了实现最佳性能，请尝试确保堆从不分页。
占有率为 70% 时，垃圾回收频率过高。
更改 -Xminf 的设置。缺省值为 0.3，通过扩展堆尝试维持 30% 的可用空间。例如，设置为 0.4，这会将此可用空间目标增加到 40%，并降低垃圾回收的频率。
暂停时间过长。
如果应用程序使用了很多短生命周期对象，或者是基于事务（即事务中对象的生存期不会超过事务的落实期）或者将堆空间分成片段，请尝试使用 -Xgcpolicy:gencon 垃圾回收策略。 该策略对短生命周期对象的处理方式区别于长生命周期对象，并能减少暂停时间和堆分段存储。
在其他情况下，如果可以接受吞吐量降低，请尝试使用 -Xgcpolicy:optavgpause 策略。 在堆占用率增加时，该策略会减少暂停时间并使它们更加一致。 尽管对于不同的应用程序，该值有所不同，但是，它的确会使吞吐量降低约 5%。
如果在全局垃圾回收中由于堆的大小很大，不能接受暂停时间，请尝试使用 -Xgcpolicy:balanced。 均衡的垃圾回收策略还能解决频发的类卸装问题，从中会创建很多类装入器，但是需要卸载全局回收。 该策略在 64 位平台上可用，并且必须和 -Xcompressedrefs 选项一起使用。 该策略旨在用于堆大小大于 4 GB 的环境。
以下是一些有用的提示：
确保堆从不分页；即，最大堆大小必须能够包含在物理内存中。
避免使用终止程序。您无法保证终止程序何时运行，而且它们通常会导致问题。如果确实需要使用终止程序，请尝试避免在使用终止程序方法时分配对象。verbose:gc 跟踪显示是否在调用终止程序。
避免压缩。verbose:gc 跟踪显示是否正在发生压缩。压缩通常是由于较大内存分配请求所导致的。分析较大内存分配请求并尽可能避免这些请求。例如，如果是较大的数组，请尝试将它们拆分为更小的数组。


常见配置汇总
堆设置
-Xms:初始堆大小
-Xmx:最大堆大小
-XX:NewSize=n:设置年轻代大小
-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
-XX:MaxPermSize=n:设置持久代大小
收集器设置
-XX:+UseSerialGC:设置串行收集器
-XX:+UseParallelGC:设置并行收集器
-XX:+UseParalledlOldGC:设置并行年老代收集器
-XX:+UseConcMarkSweepGC:设置并发收集器
垃圾回收统计信息
-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:filename
并行收集器设置
-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
并发收集器设置
-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

四、调优总结

年轻代大小选择
响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。
年老代大小选择
响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
并发垃圾收集信息
持久代并发收集次数
传统GC信息
花在年轻代和年老代回收上的时间比例
减少年轻代和年老代花费的时间，一般会提高应用的效率
吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。
较小堆引起的碎片问题
因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：
-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。
-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩